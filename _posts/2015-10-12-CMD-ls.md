---
layout: post
title: The implementation of 'ls'
categories: Linux
tags: Linux系统编程

---

### Linux系统`ls`命令的实现

**涉及的系统函数：**

* struct DIR* opendir(const char * path);
* struct dirent* readdir(DIR *dirp);
* int lstat(const char *path, struct stat *buf);

{% highlight c linenos %}
   struct stat {
	   dev_t     st_dev;     /* ID of device containing file */
	   ino_t     st_ino;     /* inode number */
	   mode_t    st_mode;    /* protection */
	   nlink_t   st_nlink;   /* number of hard links */
	   uid_t     st_uid;     /* user ID of owner */
	   gid_t     st_gid;     /* group ID of owner */
	   dev_t     st_rdev;    /* device ID (if special file) */
	   off_t     st_size;    /* total size, in bytes */
	   blksize_t st_blksize; /* blocksize for file system I/O */
	   blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
	   time_t    st_atime;   /* time of last access */
	   time_t    st_mtime;   /* time of last modification */
	   time_t    st_ctime;   /* time of last status change */
   };
{% endhighlight %}

* gettimeofday(struct timeval *tv,struct timezone *tz);
* struct tm* localtime(const time_t *timep);
* size_t strftime(char *s, size_t max, const char *format,const struct tm *tm);

{% highlight c linenos %}
int list_common(){
	DIR *dir = opendir(".");
	if(dir == NULL) return 0;
	struct dirent *dt;
	struct stat sbuf;
	while((dt = readdir(dir)) != NULL){
		if(lstat(dt->d_name, &sbuf) < 0 || dt->d_name[0] == '.') continue;
		char perms[] = "----------";
		mode_t mode = sbuf.st_mode;
		switch (mode & S_IFMT){
		case S_IFREG:
			perms[0] = '-';break;
		case S_IFDIR:
			perms[0] = 'd';break;
		case S_IFLNK:
			perms[0] = 'l';break;
		case S_IFIFO:
			perms[0] = 'p';break;
		case S_IFSOCK:
			perms[0] = 's';break;
		case S_IFCHR:
			perms[0] = 'c';break;
		case S_IFBLK:
			perms[0] = 'b';break;
		default:
			perms[0] = '?';
		}
	
		if(mode & S_IRUSR) perms[1] = 'r';
		if(mode & S_IWUSR) perms[2] = 'w';
		if(mode & S_IXUSR) perms[3] = 'x';

		if(mode & S_IRGRP) perms[4] = 'r';
		if(mode & S_IWGRP) perms[5] = 'w';
		if(mode & S_IXGRP) perms[6] = 'x';

		if(mode & S_IROTH) perms[7] = 'r';
		if(mode & S_IWOTH) perms[8] = 'w';
		if(mode & S_IXOTH) perms[9] = 'x';

		if(mode & S_ISUID) perms[3] = (perms[3] == 'x') ? 's' : 'S';
		if(mode & S_ISGID) perms[6] = (perms[5] == 'x') ? 's' : 'S';
		if(mode & S_ISVTX) perms[9] = (perms[9] == 'x') ? 's' : 'S';

		char buf[2014] = {0};
		int off = 0;
		off += sprintf(buf + off, "%s ",perms);
		off += sprintf(buf + off, "%3d %-8d %-8d ", (int)sbuf.st_nlink, (int)sbuf.st_uid, (int)sbuf.st_gid);
		off += sprintf(buf + off, "%8lu ", (unsigned long)sbuf.st_size);
		const char *p_data_format = "%b %e %H:%M";
		struct timeval tv;
		gettimeofday(&tv, NULL);
		time_t local_time = tv.tv_sec;
		if(sbuf.st_mtime > local_time || local_time - sbuf.st_mtime > 60*60*24*182){
			p_data_format = "%b %e %Y";
		}
		char databuf[64] = {0};
		strftime(databuf, sizeof(databuf), p_data_format, localtime(&local_time));
		off += sprintf(buf + off, "%s ", databuf);
		if(S_ISLNK(sbuf.st_mode)){
			char tmp[1024] = {0};
			readlink(dt->d_name, tmp, sizeof(tmp));
			off += sprintf(buf + off, "%s -> %s\r\n", dt->d_name, tmp);
		}
			
		else
			off += sprintf(buf + off, "%s\r\n", dt->d_name);
		printf("%s", buf);
	}
	closedir(dir);
	return 1;
}

{% endhighlight %}

